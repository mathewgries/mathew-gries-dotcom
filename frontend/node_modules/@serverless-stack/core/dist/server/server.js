"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.start = void 0;
const express_1 = __importDefault(require("express"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const child_process_1 = require("child_process");
const cross_spawn_1 = __importDefault(require("cross-spawn"));
const API_VERSION = "2018-06-01";
function start(opts) {
    const app = express_1.default();
    const funs = {};
    const pending = {};
    // For .NET runtime, the "aws-lambda-dotnet" package sets the type to
    // "application/*+json" for requests made to the error endpoint.
    app.use(express_1.default.json({
        type: ["application/json", "application/*+json"],
        limit: "10mb",
        strict: false,
    }));
    app.get(`/:fun/${API_VERSION}/runtime/invocation/next`, async (req, res) => {
        console.log(req.path);
        const { fun } = req.params;
        const promise = new Promise((resolve) => {
            funs[fun] = resolve;
        });
        const payload = await promise;
        res.set({
            "Lambda-Runtime-Aws-Request-Id": payload.context.awsRequestId,
            "Lambda-Runtime-Deadline-Ms": payload.timeoutAt,
            "Lambda-Runtime-Invoked-Function-Arn": payload.context.invokedFunctionArn,
            //'Lambda-Runtime-Trace-Id â€“ The AWS X-Ray tracing header.
            "Lambda-Runtime-Client-Context": JSON.stringify(payload.context.identity || {}),
            "Lambda-Runtime-Cognito-Identity": JSON.stringify(payload.context.clientContext || {}),
        });
        res.json(payload);
    });
    app.post(`/:fun/${API_VERSION}/runtime/invocation/:awsRequestId/response`, (req, res) => {
        console.log(req.path);
        const { awsRequestId } = req.params;
        const { resolve } = pending[awsRequestId];
        console.log(req.body);
        resolve(req.body);
        res.status(202);
        res.json("ok");
    });
    app.post(`/:fun/${API_VERSION}/runtime/invocation/:awsRequestId/error`, (req, res) => {
        console.log(req.path);
        const { awsRequestId } = req.params;
        const { reject } = pending[awsRequestId];
        reject(req.body);
    });
    const server = app.listen(opts.port, () => {
        for (const line of fs_1.default
            .readFileSync(path_1.default.join(opts.rootDir, ".build", "sst-functions.jsonl"))
            .toString()
            .trim()
            .split("\n")) {
            if (!line)
                continue;
            const parsed = JSON.parse(line);
            console.log(parsed);
            const { definition } = parsed;
            fs_1.default.mkdirSync(parsed.outPath);
            child_process_1.execSync(definition.build.command, {
                env: {
                    ...process.env,
                    ...definition.build.environment,
                },
                stdio: "inherit",
            });
            const p = cross_spawn_1.default(definition.start.command, definition.start.args || [], {
                env: {
                    ...process.env,
                    ...definition.start.environment,
                    AWS_LAMBDA_RUNTIME_API: `localhost:${opts.port}/${parsed.id}`,
                },
            });
            p.on("close", console.log);
            p.stdout.on("data", (i) => console.log(i.toString()));
            p.stderr.on("data", (i) => console.log(i.toString()));
        }
    });
    return {
        server,
        async invoke(fun, payload) {
            const f = funs[fun];
            const promise = new Promise((resolve, reject) => {
                pending[payload.context.awsRequestId] = { resolve, reject };
            });
            const time = Date.now();
            f(payload);
            const result = await promise;
            console.log(Date.now() - time);
            return result;
        },
    };
}
exports.start = start;
